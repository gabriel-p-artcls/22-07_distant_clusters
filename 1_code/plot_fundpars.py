
import pickle
from astropy.io import ascii
from numpy.random import MT19937, RandomState, SeedSequence
from . import prep_plots

"""
Function to generate the proper motions + fundamental parameters plot. This
file needs to be in the 'packages/out/' folder of ASteCA and called from
'func_caller()' with:

    from .out import plot_fundpars
    plot_fundpars.main(npd, pd, clp, td)
    return

before the call to make the 'D3' plot.

The input data file for the clusters must be the members files (ie: members
only must be present).

The pickle files generated by ASteCA in the run to estimate the fundamental
parameters must be present for all the clusters. The code is then run in 'read'
mode to pick up these files.

The proper motions must be read, and the 'C3' image must be generated in order
to store the proper motions plot data. Disable 'D1' and 'D2' plots to save
time.

The 'pms_folder' variable must point to the correct folder with the files
that contain the entire frames.

The 'R1' line in 'asteca.ini' must include the required range of parameter
values.

The 'D3_sol' parameter was originally set to 'mean'.

The output is a single file called 'fundpars.pickle'. This file then needs
to be processed with the 'plot_fund_pars_pickle.py' code to generate the
final images.

"""

pms_folder = '/media/gabriel/rest/Dropbox_nosync/Papers/2022/distant_clusters/2_pipeline/1_data_filter/out/'


def main(npd, pd, clp, td):
    """
    """

    # Set random seed
    seed = 12345  # np.random.randint(100000000)
    print("Random seed: {}".format(seed))
    RandomState(MT19937(SeedSequence(seed)))

    name = npd['clust_name']
    if name == 'tombaugh2':
        name = 'TOMB2'
    elif name == 'czernik30':
        name = 'CZER30'
    elif name == 'kronberger31':
        name = 'KRON31'
    elif name == 'kronberger39':
        name = 'KRON39'
    elif "fsr" in name:
        name = name.replace('fsr', 'F').upper()
    elif "eso" in name:
        name = name.replace('eso0', 'E').upper()
    elif "vdbh" in name:
        name = name.replace('vd', '').upper()
    elif "saurer" in name:
        name = name.replace('saurer', 'sau').upper()
    else:
        name = name.upper()

    data_all = ascii.read(pms_folder + npd['clust_name'] + '.dat')
    pms_data = {'pmRA': clp['clreg_PMs']['pmRA'],
                'pmDE': clp['clreg_PMs']['pmDE']}

    fit_pars = clp['isoch_fit_params']

    shift_isoch, synthcl_Nsigma = prep_plots.isoch_sigmaNreg(
        td['fundam_params'], pd['D3_sol'], td['theor_tracks'],
        td['m_ini_idx'], td['ext_coefs'], td['N_fc'], td['ext_unif_rand'],
        fit_pars, clp['isoch_fit_errors'], clp['syntClustArgs'])

    diag_fit_inv, dummy = prep_plots.da_phot_diag(clp['cl_max_mag'], [])
    cl_sz_pt = prep_plots.phot_diag_st_size(diag_fit_inv)

    # Plot one ore more rows of CMDs/CCDs.
    bf_bin_edges = clp['obs_clust'][0]
    hr_diags = prep_plots.packData(
        pd['lkl_method'], pd['colors'], pd['filters'], clp['cl_max_mag'],
        clp['synth_cl_phot'], clp['binar_idx'], clp['col_0_comb'],
        clp['mag_0_comb'], clp['col_1_comb'], bf_bin_edges,
        shift_isoch, synthcl_Nsigma)
    for (x_phot_all, y_phot_all, x_phot_obs, y_phot_obs, x_synth_phot,
         y_synth_phot, binar_idx, hess_xedges, hess_yedges, x_isoch,
         y_isoch, phot_Nsigma, x_name, y_name, yaxis, i_obs_x,
         i_obs_y, gs_y1, gs_y2) in hr_diags:

        hess_x, hess_y, HD = prep_plots.get_hess(
            [x_phot_obs, y_phot_obs], [x_synth_phot, y_synth_phot],
            hess_xedges, hess_yedges)
        x_ax, y_ax = prep_plots.ax_names(x_name, y_name, yaxis)
        x_max_cmd, x_min_cmd, y_min_cmd, y_max_cmd =\
            prep_plots.diag_limits(yaxis, x_phot_all, y_phot_all)
        sy_sz_pt = prep_plots.phot_diag_st_size(x_synth_phot)

        # Main photometric diagram of observed cluster.
        i_y = 0 if yaxis == 'mag' else 1
        # x axis is always a color so this the index is fixed to '1'.
        # y axis is not, so the 'i_y' index determines what goes there.
        obs_x, obs_y, _ = diag_fit_inv[1][i_obs_x],\
            diag_fit_inv[i_y][i_obs_y], diag_fit_inv[2]
        err_bar = prep_plots.error_bars(
            clp['cl_max_mag'], x_min_cmd, clp['err_lst'])

        arglist = [
            # pl_hess_diag: Hess diagram 'observed - synthetic'
            [data_all, pms_data, cl_sz_pt],
            #
            [gs_y1, gs_y2, x_min_cmd, x_max_cmd, y_min_cmd, y_max_cmd,
             x_ax, y_ax, obs_x, obs_y, err_bar, cl_sz_pt, hess_xedges,
             hess_yedges, x_isoch, y_isoch, phot_Nsigma],
            # pl_bf_synth_cl: Best fit synthetic cluster obtained.
            [x_min_cmd, x_max_cmd, y_min_cmd, y_max_cmd, x_ax, y_ax,
             hess_xedges, hess_yedges, x_synth_phot, y_synth_phot, sy_sz_pt,
             binar_idx, x_isoch, y_isoch, name]
        ]

        with open("fundpars.pickle", 'ab') as fp:
            pickle.dump({name: arglist}, fp)
